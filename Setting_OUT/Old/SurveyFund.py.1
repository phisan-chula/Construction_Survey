#
#
#
#
#
import pygeodesy as pgd
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

def dd2DMS( dd, PREC=1, POS=''  ):
    '''conver degree to DMS string'''
    return pgd.dms.toDMS( dd, prec=PREC,pos=POS )

def rad2DMS( rad, PREC=1, POS='' ):
    '''conver radian to DMS string'''
    return pgd.dms.toDMS( np.degrees(rad), prec=PREC, pos=POS )

def DMS2dd( ddmmss ):
    ''' convert string or float DD.MMSS from total station 
        to decimal degree. Format DD.MMSS is often used by TS '''
    if type(ddmmss) is not str:
        ddmmss = f'{ddmmss:f}'    
    dms = ddmmss.split('.')
    d = float( dms[0] )
    SIGN = +1. if d>0.0 else -1.
    m = SIGN*float( dms[1][0:2])/60
    s = SIGN*float( dms[1][2:4])/3600
    return d+m+s

def AngCW(dirBS,dirFS,MODE='degrees'):
    ang = dirFS-dirBS 
    dir_mid = ang/2 + dirBS
    #import pdb ; pdb.set_trace()
    if MODE=='degrees':
        ang = divmod( ang,360 )[1]
    elif MODE=='radians':
        ang = divmod( ang,2*np.pi )[1]
    PlotAngCW( dirBS,dirFS, ang, dir_mid, MODE )
    return ang
    
def PlotAngCW( dirBS,dirFS, ang, dir_mid, MODE ):
    if MODE=='radians':
        ang = np.degrees( ang )
    AngFUNC= np.radians if MODE=='degrees' else lambda x:x
    fig,ax = plt.subplots()
    for bf,dir in (('BS',dirBS),('FS',dirFS)) :
        dir_ = AngFUNC(dir)
        dx = np.sin(dir_); dy = np.cos(dir_)
        LINE = 'ro-' if bf=='BS' else 'go-'
        ax.plot( [0,dx], [0,dy], LINE, linewidth=2 ) 
        ax.text( dx,dy, f'({bf}) {dir:}' )
    dx = 0.3*np.sin( AngFUNC(dir_mid) )
    dy = 0.3*np.cos( AngFUNC(dir_mid) )
    ax.annotate( f'{ang:3.0f}', xy=(0,0) , xycoords='data',
            xytext=(dx,dy), textcoords='data',
            arrowprops=dict(arrowstyle="->",
                            connectionstyle="arc3,rad=.2"))
    #import pdb ; pdb.set_trace()
    ax.set_xlim( -1, +1 ); ax.set_ylim( -1, +1 )
    ax.set_aspect('equal', 'box')
    ax.xaxis.set_ticklabels([]); ax.yaxis.set_ticklabels([])
    ax.grid()
    if MODE=='degrees':
        plt.savefig( f'CACHE/{dirBS:03d}_{dirFS:03d}_{ang:03.0f}.png' )  
    else:
        dirBS=np.degrees(dirBS); dirFS=np.degrees(dirFS)
        #plt.savefig( f'CACHE/{dirBS:03d}_{dirFS:03d}_{ang:03.0f}.png' )  
        plt.savefig( f'CACHE/{dirBS:.2f}_{dirFS:.2f}_{ang:03.0f}.png' )  
    plt.clf(); plt.close()
    return

####################################################################
if __name__=="__main__":
    import random 
    random.seed( 999 )
    for ang in ( '123.4512', 123.4512 , '-123.4512', -123.4512 ):
        dd = DMS2dd( ang )
        rad = np.radians(dd)
        print( dd2DMS( dd,POS='+' ) )
        print( rad2DMS( rad, POS='+' ) )

    print(70*'=')
    dir_bs = random.sample( range(0,360,10), 36 )
    dir_fs = random.sample( range(0,360,10), 36 )
    #for bs,fs in list(zip( dir_bs,dir_fs )):
    #    ang = AngCW(bs,fs,MODE='degrees' )
    #    print( f'BS={bs}  FS={fs}  AngCW= {ang}' )

    print(70*'=')
    dir_bs = np.radians( np.array( dir_bs ))
    dir_fs = np.radians( np.array( dir_fs ))
    for bs,fs in list(zip( dir_bs,dir_fs )):
        ang = AngCW(bs,fs,MODE='radians' )
        print( f'BS={bs}  FS={fs}  AngCW= {ang}' )
    #import pdb ; pdb.set_trace()

